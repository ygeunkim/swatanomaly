# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Squared l2 Distance between two windows
#'
#' @description
#' This function gives distance matrix between two windows in multivariate time series
#' @param x NumericMatrix. first window.
#' @param y NumericMatrix. second window.
#' @return double. squared l2 distance matrix form.
#' @details
#' Compute
#' \deqn{d = x_{ij} - y_{kl}}
#' element-wise. After that,
#' \deqn{\frac{\sqrt{\sum{d}}}{wp}}
#' where w is the wize of window, and p is the number of variables.
#' @references
#' Yun, J.-H., Hwang, Y., Lee, W., Ahn, H.-K., & Kim, S.-K. (2018). \emph{Statistical Similarity of Critical Infrastructure Network Traffic Based on Nearest Neighbor Distances} (Vol. 11050, pp. 1â€“23). Presented at the Research in Attacks, Intrusions, and Defenses, Cham: Springer International Publishing. \url{http://doi.org/10.1007/978-3-030-00470-5_27}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
compute_euc <- function(x, y) {
    .Call('_swatanomaly_compute_euc', PACKAGE = 'swatanomaly', x, y)
}

detect <- function(y, win, jump, thr) {
    .Call('_swatanomaly_detect', PACKAGE = 'swatanomaly', y, win, jump, thr)
}

#' Expand Label into Window
#'
#' @description
#' When detection label is given only one value per window,
#' this function expands it.
#'
#' Warning: Do not use jump parameter against confusion.
#' @param x LogicalVector detected label
#' @param win int Window size
#' @return LogicalVector
#' @details
#' In the window, the values are the same.
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
expand_label <- function(x, win) {
    .Call('_swatanomaly_expand_label', PACKAGE = 'swatanomaly', x, win)
}

#' Aggregate Multivariate Time Series for K-L divergence
#'
#' @description
#' This functions aggregates multivariate times series into univariate time series.
#' See details.
#' @param x NumericMatrix multivariate time series
#' @return NumericVector
#' @details
#' To eliminate local spikes, compute usual distance.
#' \deqn{\sum_{i \neq j}^p \lvert x_{ti} - x_{tj}}
#' where p is the number of variables, and t is the index of time.
#' This enables to explain the correlation between the series.
#' @references Cho, J., Tariq, S., Lee, S., Kim, Y. G., & Woo, S. (2019). \emph{Contextual Anomaly Detection by Correlated Probability Distributions using Kullback-Leibler Divergence}. Workshop on Mining and Learning From Time Series. \url{http://doi.org/10.1145/nnnnnnn.nnnnnnn}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
aggregate_mts <- function(x) {
    .Call('_swatanomaly_aggregate_mts', PACKAGE = 'swatanomaly', x)
}

#' Gaussian Kernel Density Estimation in C++
#'
#' @description
#' This function calls \link[stats]{density.default} in Rcpp.
#' Since it calls an R function to Rcpp, it might be slower even than R function itself.
#' This one is just for the sake of defining other functions in Rcpp syntax more easily.
#' @param x NumericVector data for estimation. x of \link[stats]{density.default}.
#' @return NumericMatrix of 2 columns.
#' First column is the n coordinates of the points where the density is estimated (x).
#' Second column is the estimated density values (y).
#' @details
#' Note that \link[stats]{density.default} has various arguments and options.
#' This function, howerver, only computes gaussian kernel.
#' It tries to detect windows derived from other Normal distribution.
#' @seealso
#'    \link[stats]{density.default}
#'    \code{\link{est_density}}
#' @references Cho, J., Tariq, S., Lee, S., Kim, Y. G., & Woo, S. (2019). \emph{Contextual Anomaly Detection by Correlated Probability Distributions using Kullback-Leibler Divergence}. Workshop on Mining and Learning From Time Series. \url{http://doi.org/10.1145/nnnnnnn.nnnnnnn}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @importFrom stats density
#' @export
density_cpp <- function(x) {
    .Call('_swatanomaly_density_cpp', PACKAGE = 'swatanomaly', x)
}

find_support <- function(x1, x2) {
    .Call('_swatanomaly_find_support', PACKAGE = 'swatanomaly', x1, x2)
}

#' Kullback-Leibler divergence estimation between two densities
#'
#' @description
#' This function computes Kullback-Leibler divergence from f2 to f1.
#' When sliding windows, f1 is the previous pdf and f2 is the current pdf.
#' @param f1 NumericMatrix density estimated by \code{\link{est_density}}. previous pdf.
#' @param f2 NumericMatrix density estimated by \code{\link{est_density}}. current pdf.
#' @return double
#' @details
#' Let \eqn{\mathcal{X}} be the support of f1. Then K-L divergence from f2 to f1 is defined by
#' \deqn{E_{X_1} \log \frac{f_1 (x)}{f_2 (x)}}
#' Probability mass is estimated from density by
#' \deqn{f \Delta x}
#' In turn, we can compute K-L divergence using mass p and q by
#' \deqn{\sum_{\mathcal{X}} p(x) \log \frac{p (x)}{q (x)}}
#' To estimate this value, first use \code{\link{est_density}} or \code{\link{density_cpp}}, and estimate density of each window.
#' @seealso
#'     \code{\link{est_density}}
#'     \code{\link{density_cpp}}
#' @references Cho, J., Tariq, S., Lee, S., Kim, Y. G., & Woo, S. (2019). \emph{Contextual Anomaly Detection by Correlated Probability Distributions using Kullback-Leibler Divergence}. Workshop on Mining and Learning From Time Series. \url{http://doi.org/10.1145/nnnnnnn.nnnnnnn}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
compute_kl <- function(f1, f2) {
    .Call('_swatanomaly_compute_kl', PACKAGE = 'swatanomaly', f1, f2)
}

#' Fixed lambda Algorithm
#'
#' @description
#' This function implement dynamic \eqn{\lambda} algorithm for K-L divergence based on gaussianity.
#' @param x NumericVector univariate data set.
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param lambda double threshold of K-L divergence.
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return NumericVector
#' @details
#' Slide windows. In each window, estimate a density based on \link[stats]{density.default}.
#' Between two neighbored window, K-L divergence from current density to previous density can be computed using \code{\link{compute_kl}}.
#' If K-L divergence is less than \eqn{\lambda}, update the threshold by
#' @seealso
#'    \link[stats]{density.default}
#'     \code{\link{est_density}}
#'     \code{\link{density_cpp}}
#'     \code{\link{compute_kl}}
#' @references Cho, J., Tariq, S., Lee, S., Kim, Y. G., & Woo, S. (2019). \emph{Contextual Anomaly Detection by Correlated Probability Distributions using Kullback-Leibler Divergence}. Workshop on Mining and Learning From Time Series. \url{http://doi.org/10.1145/nnnnnnn.nnnnnnn}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
kl_fix <- function(x, win, jump, lambda, display_progress = FALSE) {
    .Call('_swatanomaly_kl_fix', PACKAGE = 'swatanomaly', x, win, jump, lambda, display_progress)
}

#' Dynamic lambda Algorithm
#'
#' @description
#' This function implement dynamic \eqn{\lambda} algorithm for K-L divergence based on gaussianity.
#' @param x NumericVector univariate data set.
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param lambda_p double initializing lambda_p for the threshold.
#' @param eps double initializing epsilon for the threshold.
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return List,
#' First element is kl divergence named divergence.
#' Second element is threshold (lambda) for detecting anomaly named threshold.
#' @details
#' Basically, this algorithm use neighboring-window method.
#' Slide windows. In each window, estimate a density based on \link[stats]{density.default}.
#' Between two neighbored window, K-L divergence from current density to previous density can be computed using \code{\link{compute_kl}}.
#' Given \eqn{\lambda^{\prime}} and \eqn{\epsilon}, set threshold \eqn{\lambda} by \eqn{\lambda = \lambda^{\prime} \epsilon}.
#' If K-L divergence is less than \eqn{\lambda}, update the threshold by
#' \deqn{\lambda = \lambda^{\prime} (d_{j - 2} + \epsilon)}
#' where \eqn{d_{j - 2}} is the K-L divergence two-step before.
#' Otherwise, keep using the old one.
#' @seealso
#'    \link[stats]{density.default}
#'     \code{\link{est_density}}
#'     \code{\link{density_cpp}}
#'     \code{\link{compute_kl}}
#' @references Cho, J., Tariq, S., Lee, S., Kim, Y. G., & Woo, S. (2019). \emph{Contextual Anomaly Detection by Correlated Probability Distributions using Kullback-Leibler Divergence}. Workshop on Mining and Learning From Time Series. \url{http://doi.org/10.1145/nnnnnnn.nnnnnnn}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
kl_dynamic <- function(x, win, jump, lambda_p, eps, display_progress = FALSE) {
    .Call('_swatanomaly_kl_dynamic', PACKAGE = 'swatanomaly', x, win, jump, lambda_p, eps, display_progress)
}

#' Matching KL divergence label to individual observation
#'
#' @description
#' Give KL divergence anomaly prediction of each window to individual observation.
#' @param d LogicalVector anomaly of \code{\link{kl_dynamic}} or the result of detection by fixed algorithm
#' @param win int window size.
#' @return NumericVector of number identical to the original series except the last window.
#' @details
#' This function is not appropriate when jump option is used.
#' In other words, use only when the series has been partitioned.
#' @seealso
#'     \code{\link{kl_fix}}
#'     \code{\link{kl_dynamic}}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
match_kl <- function(d, win) {
    .Call('_swatanomaly_match_kl', PACKAGE = 'swatanomaly', d, win)
}

#' Online KL Algorithm
#'
#' @description
#' This function implement Dynamic lambda algorithm by online.
#' @param x NumericVector. univariate data set that consits of non-anomaly.
#' @param newx NumericVector. univariate data set that has possibility of anomaly.
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param lambda_p double initializing lambda_p for the threshold.
#' @param eps double initializing epsilon for the threshold.
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return List,
#' First element is kl divergence named divergence.
#' Second element is threshold (lambda) for detecting anomaly named threshold.
#' @details
#' This is an online version for dynamic lambda algorithm.
#' In this setting, normal data set is given. We keep updating new data set that has possibility of anomaly.
#' This function tries to detect anomaly in this updated set.
#' First, estimate kernel in the normal set.
#' Next, estimate kernel in the first window of new data set.
#' Compute the KL and see if the window is anomaly.
#' If it is normal, estimate kernel in the normal set including the first window.
#' Otherwise, just keep the former kernel.
#' Compute the KL from second window and see if this window is anomaly.
#' Repeat this procedure while updating lambda.
#' @seealso
#'    \link[stats]{density.default}
#'     \code{\link{est_density}}
#'     \code{\link{density_cpp}}
#'     \code{\link{compute_kl}}
#'     \code{\link{kl_dynamic}}
#' @references Cho, J., Tariq, S., Lee, S., Kim, Y. G., & Woo, S. (2019). \emph{Contextual Anomaly Detection by Correlated Probability Distributions using Kullback-Leibler Divergence}. Workshop on Mining and Learning From Time Series. \url{http://doi.org/10.1145/nnnnnnn.nnnnnnn}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
kl_online <- function(x, newx, win, jump, lambda_p, eps, display_progress = FALSE) {
    .Call('_swatanomaly_kl_online', PACKAGE = 'swatanomaly', x, newx, win, jump, lambda_p, eps, display_progress)
}

#' Simple Onlie KL Algorithm
#'
#' @description
#' This function simplifies Online KL algorithm \code{\link{kl_online}}.
#' @param x NumericVector. univariate data set that consits of non-anomaly.
#' @param newx NumericVector. univariate data set that has possibility of anomaly.
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param lambda_p double initializing lambda_p for the threshold.
#' @param eps double initializing epsilon for the threshold.
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return List,
#' First element is kl divergence named divergence.
#' Second element is threshold (lambda) for detecting anomaly named threshold.
#' @details
#' Unlike \code{\link{kl_online}}, this uses initial normal set for the first non-anomaly density estimation.
#' The density does not change until the algorithm ends.
#' @seealso
#'    \link[stats]{density.default}
#'     \code{\link{est_density}}
#'     \code{\link{density_cpp}}
#'     \code{\link{compute_kl}}
#'     \code{\link{kl_dynamic}}
#'     \code{\link{kl_online}}
#' @references Cho, J., Tariq, S., Lee, S., Kim, Y. G., & Woo, S. (2019). \emph{Contextual Anomaly Detection by Correlated Probability Distributions using Kullback-Leibler Divergence}. Workshop on Mining and Learning From Time Series. \url{http://doi.org/10.1145/nnnnnnn.nnnnnnn}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
kl_faston <- function(x, newx, win, jump, lambda_p, eps, display_progress = FALSE) {
    .Call('_swatanomaly_kl_faston', PACKAGE = 'swatanomaly', x, newx, win, jump, lambda_p, eps, display_progress)
}

#' Sums of squares in C++
#'
#' @description Compute a SS in C++
#' @param x NumericVector
#' @return double
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
sum_sq <- function(x) {
    .Call('_swatanomaly_sum_sq', PACKAGE = 'swatanomaly', x)
}

#' Remove row index of a matrix in C++
#'
#' @description
#' This function removes a row index of NumericMatrix in Rcpp.
#' @param x NumericMatrix
#' @param rowID IntegerVector row ids to be removed.
#' @return NumericMatrix
#' @useDynLib swatanomaly
#' @references \url{https://stackoverflow.com/questions/33507695/rcpp-numericmatrix-how-to-erase-a-row-column}
#' @importFrom Rcpp sourceCpp
#' @export
row_erase <- function(x, rowID) {
    .Call('_swatanomaly_row_erase', PACKAGE = 'swatanomaly', x, rowID)
}

#' Sequence by 1 in Rcpp
#'
#' @description
#' This function generates a integer sequence with increment of 1 in Rcpp.
#' @param from int the starting value of the sequence.
#' @param to int the end value of the sequence.
#' @return IntegerVector
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
seq_rcpp <- function(from, to) {
    .Call('_swatanomaly_seq_rcpp', PACKAGE = 'swatanomaly', from, to)
}

sub_mat <- function(x, row, col) {
    .Call('_swatanomaly_sub_mat', PACKAGE = 'swatanomaly', x, row, col)
}

rep_bool <- function(x, n) {
    .Call('_swatanomaly_rep_bool', PACKAGE = 'swatanomaly', x, n)
}

rbind_mat <- function(x, y) {
    .Call('_swatanomaly_rbind_mat', PACKAGE = 'swatanomaly', x, y)
}

concat_vec <- function(x, y) {
    .Call('_swatanomaly_concat_vec', PACKAGE = 'swatanomaly', x, y)
}

compute_q7 <- function(x, prob) {
    .Call('_swatanomaly_compute_q7', PACKAGE = 'swatanomaly', x, prob)
}

#' Sliding window for NND
#'
#' @description
#' For the chosen partition, get NND for every pair of window.
#' This function is constructed for the other function.
#' @param data NumericMatrix. data to be calculated NND.
#' @param win int. window size.
#' @param jump int. shift size.
#' @param from int. First index of chosen partition.
#' @param to int. Last index of chosen partition.
#' @return NumericVector. NND vector for each window in the chosen partition.
#' @seealso
#'     \code{\link{nnd_normal}}
#'     \code{\link{pred_nnd}}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
partnnd <- function(data, win, jump, from, to) {
    .Call('_swatanomaly_partnnd', PACKAGE = 'swatanomaly', data, win, jump, from, to)
}

#' Compute NND of normal data given window distance function
#'
#' @description
#' This function computes NND of a normal data set corresponding to defined window distance.
#' @param data NumericMatrix. data to be calculated NND.
#' @param part int. the number of partition.
#' @param win int. window size.
#' @param jump int. shift size.
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return NumericVector. NND for each window. Its size is affected by "jump".
#' @details
#' First partition the whole given data set by "part".
#' Without the loss of generality, consider the first window.
#' We do not compute the distances between windows in the same window, assuming they are similar to each other.
#' Then for the first window, we consider every other slided window in the other partion.
#' Compute their distances. The minimum among the distance values is NND of the first window.
#' Repeat this procedure for every window in the partition.
#' Same for the other partition.
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
nnd_normal <- function(data, part, win, jump, display_progress = FALSE) {
    .Call('_swatanomaly_nnd_normal', PACKAGE = 'swatanomaly', data, part, win, jump, display_progress)
}

#' Compute NND for Online Data-set
#'
#' @description
#' This function computes NND of the data set which consists of anomaly.
#' @param data NumericMatrix. original data set.
#' @param newdata NumericMatrix. updated data set.
#' @param win int. window size.
#' @param jump int. shift size.
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return NumericVector. NND for each window.
#' @details
#' In the window in new data set, scan the original set sliding window.
#' Minimum distance is the NND of that window.
#' Repeat for every window.
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
pred_nnd <- function(data, newdata, win, jump, display_progress = FALSE) {
    .Call('_swatanomaly_pred_nnd', PACKAGE = 'swatanomaly', data, newdata, win, jump, display_progress)
}

#' Simple Static Threshold
#'
#' @description
#' This function detects anomaly for each window using static threshold.
#'
#' @param x NumericMatrix multivariate time series, which is forecasting error
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param threshold double threshold for anomaly
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return LogicalVector
#' @details
#' If at least one observation in the window is larger than the threshold, the entire window is anomaly.
#'
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
detect_static <- function(x, win, jump, threshold, display_progress = FALSE) {
    .Call('_swatanomaly_detect_static', PACKAGE = 'swatanomaly', x, win, jump, threshold, display_progress)
}

compute_mse <- function(x, win, jump) {
    .Call('_swatanomaly_compute_mse', PACKAGE = 'swatanomaly', x, win, jump)
}

#' Static Threshold based on MSE
#'
#' @description
#' This function detects anomaly for each window based on window MSE.
#'
#' @param x NumericMatrix multivariate time series, which is forecasting error
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param threshold double threshold for anomaly
#' @return LogicalVector
#' @details
#' If the MSE is larger than given threshold, then the window is anomaly.
#'
#' @references Pavel Filonov, Andrey Lavrentyev, and Artem Vorontsov. 2016. \emph{Multivariate industrial time series with cyber-attack simulation: Fault detection using an lstm-based predictive data model}. arXiv preprint \url{arXiv:1612.06676} (2016).
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
detect_mse <- function(x, win, jump, threshold) {
    .Call('_swatanomaly_detect_mse', PACKAGE = 'swatanomaly', x, win, jump, threshold)
}

#' p-norm of each observation
#'
#' @description
#' This function computes p-norm w.r.t. the variables.
#'
#' @param x NumericMatrix multivariate time series, which is forecasting error
#' @param norm int p-norm
#' @return NumericVector
#' @seealso
#'   \code{\link{detect_norm}}
#'   \code{\link{train_norm}}
#'
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
compute_norm <- function(x, norm) {
    .Call('_swatanomaly_compute_norm', PACKAGE = 'swatanomaly', x, norm)
}

#' Static Threshold based on p-norm
#'
#' @description
#' This function detects anomaly for each observation based on p-norm.
#'
#' @param x NumericMatrix multivariate time series, which is forecasting error
#' @param norm int p-norm
#' @param threshold double threshold for anomaly
#' @return LogicalVector
#' @details
#' If the p-norm is larger than given threshold, then the observation is anomaly.
#'
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
detect_norm <- function(x, norm, threshold) {
    .Call('_swatanomaly_detect_norm', PACKAGE = 'swatanomaly', x, norm, threshold)
}

#' Window CUSUM
#'
#' @description
#' This function computes the sum of p-norm in each window.
#'
#' @param x NumericMatrix multivariate time series, which is forecasting error
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param norm int p-norm
#' @return NumericVector
#' @details
#' This function will be used in both \code{\link{detect_cusum}} and \code{\link{train_cusum}}
#' Use error data as an input.
#'
#' @seealso
#'   \code{\link{detect_cusum}}
#'   \code{\link{train_cusum}}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
compute_cusum <- function(x, win, jump, norm) {
    .Call('_swatanomaly_compute_cusum', PACKAGE = 'swatanomaly', x, win, jump, norm)
}

#' CUSUM
#'
#' @description
#' This function detects anomaly for each window based on CUSUM.
#'
#' @param x NumericMatrix multivariate time series, which is forecasting error
#' @param win int window size.
#' @param jump int jump size for sliding window.
#' @param norm int p-norm
#' @param threshold double threshold for anomaly
#' @return LogicalVector
#' @details
#' If the p-norm is larger than given threshold, then the observation is anomaly.
#'
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
detect_cusum <- function(x, win, jump, norm, threshold) {
    .Call('_swatanomaly_detect_cusum', PACKAGE = 'swatanomaly', x, win, jump, norm, threshold)
}

