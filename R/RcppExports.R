# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Sums of squares in C++
#'
#' @description Compute a SS in C++
#' @param x NumericVector
#' @return double
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
sum_sq <- function(x) {
    .Call('_swatanomaly_sum_sq', PACKAGE = 'swatanomaly', x)
}

#' Euclidean distance between two matrices in Rcpp
#'
#' @description
#' This function computes a euclidean distance between two multivariate series using Rcpp.
#' @param x NumericMatrix column should indicate variable
#' @param y NumericMatrix column should indicate variable
#' @return double
#' @details
#' For input x and y, compute
#' \deqn{\sum \sqrt{\sum (x_{ij} - y_{ij})^2}}
#' At first, the function calculates Euclidean distance pairwisely.
#' After that, sum over every observation.
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
euc_dist <- function(x, y) {
    .Call('_swatanomaly_euc_dist', PACKAGE = 'swatanomaly', x, y)
}

#' Euclidean pdf in Rcpp
#'
#' @description
#' This function computes a euclidean NND pdf of two multivariate series using Rcpp. See details what it is.
#' @param x NumericMatrix, column should indicate variable.
#' @param partition int, equally partitioning the series.
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return NumericVector, NND pdf
#' @details
#' First partitioning the series equally.
#' Next for each partitioned block, it calculates sqrt(sum((x_i - x_j)^2)) versus the other partioned ones.
#' Find the minimum result for each block. This is NND of each block.
#' Finally, you can get NND for every block and this is pdf for NND.
#' For \code{\link{detect_nnd}}, this pdf is able to threshold.
#' Threshold is a tail of pdf, e.g. 0.99.
#' @seealso
#'    \code{\link{euc_dist}}
#'    \code{\link{nnd_thr}}
#'    \code{\link{detect_nnd}}
#' @references
#' Yun, J.-H., Hwang, Y., Lee, W., Ahn, H.-K., & Kim, S.-K. (2018). \emph{Statistical Similarity of Critical Infrastructure Network Traffic Based on Nearest Neighbor Distances} (Vol. 11050, pp. 1–23). Presented at the Research in Attacks, Intrusions, and Defenses, Cham: Springer International Publishing. \url{http://doi.org/10.1007/978-3-030-00470-5_27}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
euc_pdf <- function(x, partition, display_progress = FALSE) {
    .Call('_swatanomaly_euc_pdf', PACKAGE = 'swatanomaly', x, partition, display_progress)
}

#' Windowed NNS in Rcpp
#'
#' @description
#' This function computes a windowed NNS.
#' Compute NND sliding window across given series.
#' @param data NumericMatrix multivariate data set
#' @param win int window size for sliding window
#' @param display_progress If TRUE, display a progress bar. By default, FALSE.
#' @return NumericVector, NND for each window index (index represented by its starting point)
#' @details
#' Given n x p data, slide a window.
#' Compute NND for each pair of moving window.
#' Note that the number of windows is nrow - win + 1 given size of window win.
#' @references
#' Yun, J.-H., Hwang, Y., Lee, W., Ahn, H.-K., & Kim, S.-K. (2018). \emph{Statistical Similarity of Critical Infrastructure Network Traffic Based on Nearest Neighbor Distances} (Vol. 11050, pp. 1–23). Presented at the Research in Attacks, Intrusions, and Defenses, Cham: Springer International Publishing. \url{http://doi.org/10.1007/978-3-030-00470-5_27}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
nns_cpp <- function(data, win, display_progress = FALSE) {
    .Call('_swatanomaly_nns_cpp', PACKAGE = 'swatanomaly', data, win, display_progress)
}

#' Anomaly detection using NND
#'
#' @description
#' This function detects anomaly based on NND.
#' @param data NumericMatrix multivariate data set.
#' @param win int window size for sliding window.
#' @param thr double threshold that will be compared to nnd vector.
#' @return LogicalVector,
#' If NND is (strictly) larger than threshold then TRUE.
#' Otherwise, FALSE
#' @details
#' Given n x p data, slide a window.
#' Compute NND for each pair of moving window.
#' For threshold, users can use tail value of \code{\link{euc_pdf}}.
#' @references
#' Filonov, P., Kitashov, F., & Lavrentyev, A. (2017). \emph{RNN-based Early Cyber-Attack Detection for the Tennessee Eastman Process}. CoRR.
#'
#' Yun, J.-H., Hwang, Y., Lee, W., Ahn, H.-K., & Kim, S.-K. (2018). \emph{Statistical Similarity of Critical Infrastructure Network Traffic Based on Nearest Neighbor Distances} (Vol. 11050, pp. 1–23). Presented at the Research in Attacks, Intrusions, and Defenses, Cham: Springer International Publishing. \url{http://doi.org/10.1007/978-3-030-00470-5_27}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
detect_nnd <- function(data, win, thr) {
    .Call('_swatanomaly_detect_nnd', PACKAGE = 'swatanomaly', data, win, thr)
}

#' Anomaly detection after conducting NND
#'
#' @description
#' This function detects anomaly based on NND, given \code{\link{nns_cpp}}.
#' @param nnd NumericVector result of \code{\link{nns_cpp}}
#' @param win int window size for sliding window
#' @param thr threshold for anomaly detection, in each window
#' @return LogicalVector,
#' If NND is (strictly) larger than threshold then TRUE.
#' Otherwise, FALSE
#' @details
#' Given n x p data, slide a window.
#' Compute NND for each pair of moving window.
#' For threshold, users can use tail value of \code{\link{euc_pdf}}.
#' @references
#' Filonov, P., Kitashov, F., & Lavrentyev, A. (2017). \emph{RNN-based Early Cyber-Attack Detection for the Tennessee Eastman Process}. CoRR.
#'
#' Yun, J.-H., Hwang, Y., Lee, W., Ahn, H.-K., & Kim, S.-K. (2018). \emph{Statistical Similarity of Critical Infrastructure Network Traffic Based on Nearest Neighbor Distances} (Vol. 11050, pp. 1–23). Presented at the Research in Attacks, Intrusions, and Defenses, Cham: Springer International Publishing. \url{http://doi.org/10.1007/978-3-030-00470-5_27}
#' @useDynLib swatanomaly
#' @importFrom Rcpp sourceCpp
#' @export
detect_nndvec <- function(nnd, win, thr) {
    .Call('_swatanomaly_detect_nndvec', PACKAGE = 'swatanomaly', nnd, win, thr)
}

